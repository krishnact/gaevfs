Index: src/main/org/h2/store/fs/FileSystem.java
===================================================================
--- src/main/org/h2/store/fs/FileSystem.java	(revision 1655)
+++ src/main/org/h2/store/fs/FileSystem.java	(working copy)
@@ -48,6 +48,11 @@
      * The prefix used for the NIO (memory mapped) file system.
      */
     public static final String PREFIX_NIO_MAPPED = "nioMapped:";
+    
+    /**
+     * The prefix used for the Google App Engine (GaeVFS) file system.
+     */
+    public static final String PREFIX_GAE = "gae:";
 
     private static final ArrayList<FileSystem> SERVICES = New.arrayList();
 
@@ -68,6 +73,8 @@
             return FileSystemDiskNio.getInstance();
         } else if (fileName.startsWith(PREFIX_NIO_MAPPED)) {
             return FileSystemDiskNioMapped.getInstance();
+        } else if (fileName.startsWith(PREFIX_GAE)) {
+            return FileSystemGae.getInstance();
         }
         for (FileSystem fs : SERVICES) {
             if (fs.accepts(fileName)) {
Index: src/main/org/h2/store/fs/FileSystemGae.java
===================================================================
--- src/main/org/h2/store/fs/FileSystemGae.java	(revision 0)
+++ src/main/org/h2/store/fs/FileSystemGae.java	(revision 0)
@@ -0,0 +1,298 @@
+/*
+ * Copyright 2009 New Atlanta Communications, LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.h2.store.fs;
+
+import static com.newatlanta.commons.vfs.provider.gae.GaeVFS.resolveFile;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.sql.SQLException;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.commons.vfs.Selectors;
+
+public class FileSystemGae extends FileSystem {
+
+    private static final FileSystemGae INSTANCE = new FileSystemGae();
+
+    public static FileSystemGae getInstance() {
+        return INSTANCE;
+    }
+
+    @Override
+    public boolean canWrite(String fileName) {
+        try {
+            return resolveFile(fileName).isWriteable();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return false;
+        }
+    }
+
+    @Override
+    public void copy(String original, String copy) throws SQLException {
+        try {
+            resolveFile(copy).copyFrom(resolveFile(original),Selectors.SELECT_SELF);
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    /**
+     * Create all required directories that are required for this file.
+     *
+     * @param fileName the file name (not directory name)
+     */
+    @Override
+    public void createDirs(String fileName) throws SQLException {
+        try {
+            resolveFile(fileName).getParent().createFolder();
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public boolean createNewFile(String fileName) throws SQLException {
+        try {
+            resolveFile(fileName).createFile();
+            return true;
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    /**
+     * Create a new temporary file.
+     *
+     * @param prefix the prefix of the file name (including directory name if
+     *            required)
+     * @param suffix the suffix
+     * @param deleteOnExit if the file should be deleted when the virtual
+     *            machine exists
+     * @param inTempDir if the file should be stored in the temporary directory
+     * @return the name of the created file
+     */
+    private static AtomicInteger counter = new AtomicInteger(new Random().nextInt() & 0xffff);
+
+    @Override
+    public String createTempFile(String prefix, String suffix, boolean deleteOnExit, boolean inTempDir)
+            throws IOException {
+        org.apache.commons.vfs.FileObject tempDir;
+        if (inTempDir) {
+            tempDir = resolveFile("WEB-INF/temp");
+        } else {
+            tempDir = resolveFile(prefix).getParent();
+        }
+        tempDir.createFolder();
+
+        return tempDir.resolveFile(prefix + Integer.toString(counter.getAndIncrement())
+                + (suffix == null ? ".tmp" : suffix)).getName().getURI();
+    }
+
+    @Override
+    public void delete(String fileName) throws SQLException {
+        try {
+            resolveFile(fileName).delete();
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public void deleteRecursive(String directory) throws SQLException {
+        try {
+            resolveFile(directory).delete(Selectors.SELECT_ALL);
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public boolean exists(String fileName) {
+        try {
+            return resolveFile(fileName).exists();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean fileStartsWith(String fileName, String prefix) {
+        return fileName.startsWith(prefix);
+    }
+
+    @Override
+    public String getAbsolutePath(String fileName) {
+        try {
+            return resolveFile(fileName).getName().getURI();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return fileName;
+        }
+    }
+
+    /**
+     * Get the file name (without directory part).
+     *
+     * @param name the directory and file name
+     * @return just the file name
+     */
+    @Override
+    public String getFileName(String name) throws SQLException {
+        try {
+            return resolveFile(name).getName().getBaseName();
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public long getLastModified(String fileName) {
+        try {
+            return resolveFile(fileName).getContent().getLastModifiedTime();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return 0;
+        }
+    }
+
+    @Override
+    public String getParent(String fileName) {
+        try {
+            return resolveFile(fileName).getParent().getName().getURI();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            int i = fileName.lastIndexOf('/');
+            return (i > 0 ? fileName.substring(0, i) : "");
+        }
+    }
+
+    @Override
+    public boolean isAbsolute(String fileName) {
+        return fileName.equals(getAbsolutePath(fileName));
+    }
+
+    @Override
+    public boolean isDirectory(String fileName) {
+        try {
+            return resolveFile(fileName).getType().hasChildren();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean isReadOnly(String fileName) {
+        try {
+            return !resolveFile(fileName).isWriteable();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return false;
+        }
+    }
+
+    @Override
+    public long length(String fileName) {
+        try {
+            return resolveFile(fileName).getContent().getSize();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return 0;
+        }
+    }
+
+    @Override
+    public String[] listFiles(String directory) throws SQLException {
+        try {
+        	org.apache.commons.vfs.FileObject dirObject = resolveFile(directory);
+        	if (!dirObject.exists()) {
+        		return new String[0];
+        	}
+            org.apache.commons.vfs.FileObject[] children = dirObject.getChildren();
+            String[] files = new String[children.length];
+            for (int i = 0; i < children.length; i++) {
+                files[i] = children[i].getName().getURI();
+            }
+            return files;
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public String normalize(String fileName) throws SQLException {
+        try {
+            return resolveFile(fileName).getName().getURI();
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public InputStream openFileInputStream(String fileName) throws IOException {
+        return resolveFile(fileName).getContent().getInputStream();
+    }
+
+    /**
+     * Open a random access file object.
+     *
+     * @param fileName the file name
+     * @param mode the access mode. Supported are r, rw, rws, rwd
+     * @return the file object
+     */
+    @Override
+    public FileObject openFileObject(String fileName, String mode) throws IOException {
+        org.apache.commons.vfs.FileObject fileObject = resolveFile(fileName);
+        fileObject.createFile(); // does nothing if file exists
+        return new FileObjectGae(fileObject,mode);
+    }
+
+    @Override
+    public OutputStream openFileOutputStream(String fileName, boolean append) throws SQLException {
+        try {
+            return resolveFile(fileName).getContent().getOutputStream(append);
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public void rename(String oldName, String newName) throws SQLException {
+        try {
+            resolveFile(oldName).moveTo(resolveFile(newName));
+        } catch (IOException e) {
+            throw new SQLException(e.getMessage());
+        }
+    }
+
+    @Override
+    public boolean tryDelete(String fileName) {
+        try {
+            org.apache.commons.vfs.FileObject fileObject = resolveFile(fileName);
+            fileObject.delete();
+            return fileObject.exists();
+        } catch (IOException e) {
+            e.printStackTrace(System.err);
+            return false;
+        }
+        
+    }
+}
Index: src/main/org/h2/store/fs/FileObjectGae.java
===================================================================
--- src/main/org/h2/store/fs/FileObjectGae.java	(revision 0)
+++ src/main/org/h2/store/fs/FileObjectGae.java	(revision 0)
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2009 New Atlanta Communications, LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.h2.store.fs;
+
+import java.io.IOException;
+
+import org.apache.commons.vfs.FileSystemException;
+import org.apache.commons.vfs.RandomAccessContent;
+import org.apache.commons.vfs.util.RandomAccessMode;
+
+public class FileObjectGae implements FileObject {
+    
+    private org.apache.commons.vfs.FileObject fileObject;
+    private RandomAccessContent content;
+
+    public FileObjectGae(org.apache.commons.vfs.FileObject _fileObject, String mode) throws FileSystemException {
+        fileObject = _fileObject;
+        RandomAccessMode raMode;
+        if ( mode.equals( "r" ) ) {
+            raMode = RandomAccessMode.READ;
+        } else if ( mode.equals( "rw" ) || mode.equals( "rws" ) || mode.equals( "rwd" ) ) {
+            raMode = RandomAccessMode.READWRITE;
+        } else {
+            throw new IllegalArgumentException( "invalid mode: " + mode );
+        }
+        content = fileObject.getContent().getRandomAccessContent(raMode);
+    }
+    
+    public void close() throws IOException {
+        content.close();
+    }
+
+    public long getFilePointer() throws IOException {
+        return content.getFilePointer();
+    }
+
+    public String getName() {
+        return fileObject.getName().getURI();
+    }
+
+    public long length() throws IOException {
+        return content.length();
+    }
+
+    public void readFully(byte[] b, int off, int len) throws IOException {
+        content.readFully(b, off, len);
+    }
+
+    public void seek(long pos) throws IOException {
+        content.seek(pos);
+    }
+
+    public void setFileLength(long newLength) throws IOException {
+        content.setLength(newLength);
+    }
+
+    /**
+     * Force changes to the physical location.
+     */
+    public void sync() throws IOException {
+        fileObject.refresh();
+    }
+
+    public void write(byte[] b, int off, int len) throws IOException {
+        content.write(b, off, len);
+    }
+}
Index: src/main/org/h2/store/WriterThread.java
===================================================================
--- src/main/org/h2/store/WriterThread.java	(revision 1655)
+++ src/main/org/h2/store/WriterThread.java	(working copy)
@@ -7,6 +7,7 @@
 package org.h2.store;
 
 import java.lang.ref.WeakReference;
+import java.security.AccessControlException;
 import java.sql.SQLException;
 import org.h2.constant.SysProperties;
 import org.h2.engine.Constants;
@@ -69,12 +70,16 @@
      * @return the writer thread object
      */
     public static WriterThread create(Database database, int writeDelay) {
-        WriterThread writer = new WriterThread(database, writeDelay);
-        Thread thread = new Thread(writer);
-        thread.setName("H2 Log Writer " + database.getShortName());
-        thread.setDaemon(true);
-        thread.start();
-        return writer;
+        try {
+            WriterThread writer = new WriterThread(database, writeDelay);
+            Thread thread = new Thread(writer);
+            thread.setName("H2 Log Writer " + database.getShortName());
+            thread.setDaemon(true);
+            thread.start();
+            return writer;
+        } catch (AccessControlException e) { // Google App Engine does not allow threads
+            return null;
+        }
     }
 
     private LogSystem getLog() {
